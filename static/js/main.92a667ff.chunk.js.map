{"version":3,"sources":["components/canvas.jsx","App.js","serviceWorker.js","index.js"],"names":["Canvas","state","colsSpacing","statistics","handleChange","event","setState","target","value","split","ctx","colsCount","relativeColsHeights","canvasHeight","canvasWidth","colWidth","colsHeights","i","this","props","colorTheme","heightLevel","fillStyle","gradient","createLinearGradient","addColorStop","fillRect","fontSize","font","lineWidth","strokeText","measureText","width","fillText","obj","key","size","hasOwnProperty","refs","canvas","height","getContext","heightUnit","Math","max","map","colsHeight","drawGist","clearRect","className","ref","type","onChange","placeholder","React","Component","App","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.92a667ff.chunk.js","sourcesContent":["import React from 'react';\r\nimport './canvas.css'\r\n\r\nclass Canvas extends React.Component {\r\n\r\n    state = {\r\n        colsSpacing: 10,\r\n        statistics: []\r\n    }\r\n\r\n    drawGist( \r\n        ctx,\r\n        colsCount, \r\n        relativeColsHeights,\r\n        canvasHeight,\r\n        canvasWidth,\r\n        colWidth,\r\n        colsSpacing,\r\n        colsHeights\r\n        ) {\r\n        // отрисовываем столбцы\r\n        for (let i = 0; i < colsCount; i++) {\r\n            \r\n            // для цветовой схемы \"fullColorsCols\"\r\n            if (this.props.colorTheme === 'fullColorsCols') {\r\n\r\n                let heightLevel = relativeColsHeights[i] / canvasHeight; // определяем высоту колонки относительно канваса\r\n\r\n                // высокие колонки красим в красный, средний в желтый, низкие в зеленый \r\n                if(heightLevel > .67) {\r\n                    ctx.fillStyle = \"red\";\r\n                }else if (heightLevel > 0.33){\r\n                    ctx.fillStyle = \"orange\";\r\n                }\r\n                else {\r\n                    ctx.fillStyle = \"green\";\r\n                }\r\n\r\n            // для цветовой схемы \"gradient\"\r\n            }else if (this.props.colorTheme === 'gradient') {\r\n            \r\n                const gradient = ctx.createLinearGradient(canvasWidth, canvasHeight, canvasWidth, 0);   // градиент \"снизу-вверх\"\r\n    \r\n                // цвета градиента\r\n                gradient.addColorStop(1, 'red');\r\n                gradient.addColorStop(0.7, 'orange');\r\n                gradient.addColorStop(0.45, 'yellow');\r\n                gradient.addColorStop(0, 'green');\r\n\r\n                ctx.fillStyle = gradient;   // устанавливаем заливку градиентом\r\n            }\r\n\r\n            \r\n            ctx.fillRect(i*colWidth + colsSpacing/2, canvasHeight, colWidth - colsSpacing , -relativeColsHeights[i]);   // рисуем колонку\r\n            const fontSize = colWidth / 3 + 'px';   // размер шрифта будет зависеть от кол-ва колонок\r\n            ctx.font = `${fontSize} Arial`;\r\n            ctx.fillStyle = \"#fff\";     // ставим белый цвет заливки, чтобы подписать колонки\r\n            ctx.lineWidth = colWidth / 20; // ширина обводки\r\n            \r\n            // подписываем колонки (по центру колонки снизу)\r\n            ctx.strokeText(colsHeights[i], colWidth * i + (colWidth * .5) - ctx.measureText(colsHeights[i]).width * .5, canvasHeight - 5);   \r\n            ctx.fillText(colsHeights[i], colWidth * i + (colWidth * .5) - ctx.measureText(colsHeights[i]).width * .5, canvasHeight - 5);\r\n        }\r\n    }\r\n\r\n    componentDidMount() {\r\n        \r\n        // функция чтобы посчитать количество столбцов\r\n        const size = function(obj) {\r\n            var size = 0, key;\r\n            for (key in obj) {\r\n                if (obj.hasOwnProperty(key)) size++;\r\n            }\r\n            return size;\r\n        };\r\n        \r\n        const colsCount = size(this.props.statistics);          // количество столбцов\r\n        const colWidth = this.props.width / colsCount;          // ширина колонки\r\n        const colsHeights = this.props.statistics;              // массив высот всех колонок\r\n        const canvasWidth = this.refs.canvas.width;             // ширина канваса\r\n        const canvasHeight = this.refs.canvas.height;           // высота канваса\r\n        const colsSpacing = this.props.colsSpacing;             // промежутки между колонками\r\n\r\n\r\n        const ctx = this.refs.canvas.getContext('2d');\r\n\r\n\r\n        // ищем максимальное значение (это будет самый высокий столбец)\r\n        const maxColHeight = Math.max( ...colsHeights );\r\n\r\n        // устанавливаем \"единицу высоты\"\r\n        const heightUnit = canvasHeight/maxColHeight;\r\n        \r\n        // создаем массив с относительными высотами столбцов\r\n        const relativeColsHeights = colsHeights.map(colsHeight => colsHeight * heightUnit);\r\n\r\n        this.drawGist(ctx, colsCount, relativeColsHeights, canvasHeight, canvasWidth, colWidth, \r\n            colsSpacing, colsHeights);\r\n    }\r\n\r\n    componentDidUpdate() {\r\n        // функция чтобы посчитать количество столбцов\r\n        const size = function(obj) {\r\n            var size = 0, key;\r\n            for (key in obj) {\r\n                if (obj.hasOwnProperty(key)) size++;\r\n            }\r\n            return size;\r\n        };\r\n        \r\n        const colsCount = size(this.state.statistics);          // количество столбцов\r\n        const colWidth = this.props.width / colsCount;          // ширина колонки\r\n        const colsHeights = this.state.statistics;              // массив высот всех колонок\r\n        const canvasWidth = this.refs.canvas.width;             // ширина канваса\r\n        const canvasHeight = this.refs.canvas.height;           // высота канваса\r\n        const colsSpacing = this.state.colsSpacing;             // промежутки между колонками\r\n\r\n\r\n        const ctx = this.refs.canvas.getContext('2d');\r\n\r\n        ctx.clearRect(0, 0, canvasWidth, canvasHeight);\r\n\r\n\r\n        // ищем максимальное значение (это будет самый высокий столбец)\r\n        const maxColHeight = Math.max( ...colsHeights );\r\n\r\n        // устанавливаем \"единицу высоты\"\r\n        const heightUnit = canvasHeight/maxColHeight;\r\n        \r\n        // создаем массив с относительными высотами столбцов\r\n        const relativeColsHeights = colsHeights.map(colsHeight => colsHeight * heightUnit);\r\n\r\n        this.drawGist(ctx, colsCount, relativeColsHeights, canvasHeight, canvasWidth, colWidth, \r\n            colsSpacing, colsHeights);\r\n    }\r\n\r\n    handleChange = (event) => {\r\n        this.setState({statistics: event.target.value.split(',')});\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div className='canvas-container'>\r\n                <canvas className=\"chart\" ref=\"canvas\" width={this.props.width} height={this.props.height}/>\r\n                <input type=\"text\" value={this.state.statistics} onChange={this.handleChange} placeholder='Введите числа через запятую'/>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default Canvas;","import React from 'react';\r\nimport './App.css';\r\nimport Canvas from './components/canvas';\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <Canvas colorTheme='fullColorsCols' \r\n        colsSpacing={20} \r\n        width={600} \r\n        height={600}\r\n        statistics={[1,2,3,10,5]}\r\n      />\r\n      <Canvas colorTheme='gradient' \r\n        colsSpacing={20} \r\n        width={600} \r\n        height={600}\r\n        statistics={[1,2,3,10,5]}\r\n      />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}